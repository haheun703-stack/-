# v10.3 코드 검수 일지 (2026-02-18)

## 검수 범위
- `src/signal_engine.py` (1,661 lines) — BES v3.1 Pipeline
- `src/v8_pipeline.py` (257 lines) — Gate+Score Hybrid
- `src/v8_triggers.py` (148 lines) — T1/T2/T3 트리거
- `src/v8_gates.py` — Hard Gates
- `src/v8_scorers.py` — Scoring Engine
- `config/settings.yaml` — 전체 설정
- `scripts/backtest_v2.py` (~800 lines) — v10.1 백테스트 엔진
- `scripts/backtest_group_rotation.py` (~500 lines) — 3층 순환매 백테스트
- `scripts/blind_test_daily.py` (~540 lines) — 블라인드 테스트 자동화
- `scripts/combine_strategies.py` (~270 lines) — 전략 결합 시뮬레이션
- `src/html_report.py` (~300 lines) — HTML 보고서

---

## 1. 로직 검수

### [🔴 C0] v8_pipeline.py:194 — zone_score ratio_boost 후 1.0 초과 가능 ✅ 수정완료

**현재 코드 (수정 전):**
```python
result["zone_score"] = round(base_score + ratio_boost, 4)
```

**문제:** base_score(최대 1.0) + ratio_boost(최대 0.10) = 최대 1.10.
zone_score는 0~1.0 범위로 정의되어 있으나, 이 코드에서 클램핑 없이 1.0을 초과할 수 있음.
signal_engine.py:358에서는 `min(max(..., 0.0), 1.0)` 패턴으로 클램핑하는 것과 불일치.

**영향:** 후속 모듈에서 zone_score를 0~1 범위로 가정하면 문제 발생. 랭킹/정렬/보고서 왜곡.

**수정 완료:**
```python
result["zone_score"] = round(min(base_score + ratio_boost, 1.0), 4)
```

---

### [🟡 W7] settings.yaml:914-916 — T2 파라미터가 v8.5 역도출값으로 변경됨

**현재 값:**
- `vol_multiplier: 0.3` (v8.1 원복값 1.5에서 대폭 완화)
- `rsi_range: [30, 80]` (v8.1 원복값 [35,55]에서 대폭 확대)

**문제:** v8.5 역도출(91건)로 변경 후 v8.6 게이트 원복 시 T2만 미원복.
현재 값에서는 T2가 사실상 항상 발동 (RSI 30~80이면 대부분 종목 통과).
Gate가 충분히 필터링하므로 최종 결과에 큰 영향은 없으나,
T2의 "타이밍 필터" 역할이 무력화된 상태.

**상태:** 백테스트 원복 결과(PF 1.50, +14.7%)에서 이 값이 포함된 상태이므로
현재는 유지. 게이트 변경 작업 시 함께 검토 필요.

---

### [🔴 C1] backtest_v2.py:482 — pnl_pct 반매도 혼합 계산 부정확

**현재 코드:**
```python
pnl_pct = (sell_price / pos.buy_price - 1) if not pos.half_sold else (
    (pos.half_sold_pnl + (sell_price / pos.buy_price - 1)) / 2
)
```

**문제:** 반매도 시 half_sold_pnl은 `(sell_price / buy_price - 1)` = 순수 가격 변동률.
하지만 나머지 반은 다른 가격에 청산되므로 단순 평균이 아닌 주수 가중 필요.
half_sold 후 shares가 절반으로 줄었는데, 원래 half_shares와 남은 shares가 다를 수 있음
(홀수 주일 때 `shares // 2`로 인해 불균등).

**영향:** PF/승률에 소폭 왜곡 (대부분 거래에서는 미미하나, 원칙적으로 부정확)

**수정 제안:**
```python
# half_sold_pnl을 금액 기반으로 변경
# 또는 half_shares/remaining_shares 비율 가중
```

**상태:** v8.6에서 수수료 반영은 수정됨 (pnl_pct_net). 반매도 가중 혼합은 미수정.

---

### [🔴 C2] backtest_v2.py:438 — 반매도 day_pnl 이중 계산 가능성

**현재 코드:**
```python
# 1차 익절 (반매도)
day_pnl += proceeds - half_shares * pos.buy_price
# ...
# 나중에 전량 청산 시
pnl = proceeds - cost + (pos.half_sold_pnl * pos.allocated * 0.5 if pos.half_sold else 0)
day_pnl += pnl if mode != "A" else 0
```

**문제:** 반매도의 day_pnl과 전량 청산의 day_pnl이 각각 계산됨.
반매도 day_pnl에서 이미 실현된 수익이, 전량 청산 시 `half_sold_pnl * allocated * 0.5`로 다시 가산.
같은 날 반매도+전량청산이 동시에 일어나면 이중 계산.

**영향:** equity curve의 일일 PnL 왜곡 → MDD 계산에 간접 영향.
실제로는 같은 날 동시 발생이 드물어 영향 미미.

**상태:** 미수정

---

### [🟡 W1] signal_engine.py:920 — tc_cfg 직접 수정 (shared mutable state)

**현재 코드:**
```python
if news_score_boost >= 0.08:
    tc_cfg = self.triggers_cfg.get("trend_continuation", {})
    original_min = tc_cfg.get("min_conditions", 5)
    tc_cfg["min_conditions"] = max(original_min - 1, 3)
trend_cont = self.check_trend_continuation(df, idx)
if news_score_boost >= 0.08:
    tc_cfg["min_conditions"] = original_min
```

**문제:** `triggers_cfg`의 `trend_continuation` 딕셔너리를 직접 수정 후 원복.
멀티스레딩이나 동시 호출 시 race condition 가능.
현재 단일 스레드라 문제없지만, 원칙적으로 위험.

**영향:** 현재 동작에 영향 없음. 향후 병렬화 시 버그 발생 가능.

---

### [🟡 W2] v8_triggers.py:90 — T2 OR 조건이 너무 허용적

**현재 코드:**
```python
fired = vol_surge or rsi_in_range
```

**문제:** RSI가 35~55 범위이기만 하면 거래량 조건 없이도 트리거 발동.
대부분의 종목이 RSI 35~55 범위에 있을 수 있어 트리거가 거의 항상 발동.

**영향:** 백테스트 v8 원복 설정에서 검증됨 (PF 1.50). 현 파라미터에서는 Gate가 충분히
필터링하므로 실질 문제는 없으나, 구조적으로 T2의 독립 필터링 능력이 약함.

**상태:** 기존 알려진 이슈 (v8.6 검수 Warning). 현재 수치에서는 허용.

---

### [🟡 W3] backtest_v2.py:390 — 날짜 인덱스 pad 방식 공유 문제

**현재 코드:**
```python
loc = df.index.get_indexer([date], method="pad")
if loc[0] >= 0:
    ad = df.index[loc[0]]
    if abs((ad - date).days) <= 3:
        day_idx_map[ticker] = loc[0]
```

**문제:** 종목마다 거래일이 다를 수 있음 (상장폐지, 거래정지 등).
pad 방식으로 3일까지 허용하므로, 실제로는 금요일 데이터를 월요일에 사용 가능.
문제는 이 종목의 시그널이 "당일" 기준이 아닌 "최대 3일 전" 기준이 될 수 있음.

**영향:** 101종목 중 대부분은 동일 거래일. 비정상 종목에서만 발생하며 확률 낮음.

---

### [🟡 W4] backtest_v2.py:549-554 — 시그널일 다음날 시가 매수 (올바름) but 슬리피지 방향

**현재 코드:**
```python
next_open = float(df.iloc[idx + 1]["open"])
buy_price = next_open * (1 + SLIPPAGE)
```

**확인:** 시그널 t일 → t+1 시가 매수 → look-ahead bias 없음. **정상**
슬리피지 0.5% 상향 적용 → **정상** (불리한 방향)

---

### [🟡 W5] backtest_group_rotation.py:420 — z_data 없을 때 stock_close 대체

**현재 코드:**
```python
stock_close = z_data["close"] if z_data else pos.buy_price
```

**문제:** z_data가 없을 때 (종목 데이터 gap) buy_price를 사용.
이렇게 하면 손절/익절 판정이 매수가 기준이라 항상 PnL=0.
종목이 실제로는 크게 움직였을 수 있음.

**영향:** 데이터 gap 발생 시 (매우 드문 경우) 오판 가능.

**수정 제안:** parquet에서 직접 해당 날짜 close를 가져오는 fallback 추가.

---

### [🟡 W6] blind_test_daily.py:81 — get_kospi_regime()이 "오늘" 데이터 사용

**현재 코드:**
```python
row = df.iloc[-1]  # 최신 데이터
```

**vs backtest_v2.py:**
```python
prev = kospi_df[kospi_df.index < date]  # 전일 데이터
```

**문제:** 블라인드 테스트에서는 당일 장마감 후 실행하므로 `df.iloc[-1]`이 "오늘".
백테스트에서는 `< date`로 전일 데이터 사용.
블라인드 테스트가 장마감 후 실행되면 이는 **의도된 동작** (당일 종가 반영).
단, 장중에 실행하면 전일 종가 기준이 됨 → 일관성 이슈.

**영향:** 사용 시점에 따라 레짐 판정이 달라질 수 있음. 장마감 후 사용 시 정상.

---

## 2. 데이터 무결성

### [🟢 M1] signal_engine.py:231-245 — atr_pullback NaN 처리 양호

`pd.isna(pullback_atr) or pullback_atr < 0` → 0.0 반환. **정상**

### [🟢 M2] v8_triggers.py:48-51 — TRIX NaN 시 기본값 0

`row.get('trix', 0)` → NaN이 아닌 0 기본값. **정상**

### [🟢 M3] backtest_group_rotation.py:245-248 — std 보호

`if std_20 < 0.01: std_20 = 1.0` → 0 나누기 방지. **정상**

---

## 3. 계산 정확성

### [🟢 M4] backtest_v2.py:294-296 — ATR 간이 계산

```python
atr_arr = df["high"].values - df["low"].values
atr = np.mean(atr_arr[max(0, idx - 13):idx + 1])
```

**확인:** True Range가 아닌 High-Low만 사용. 갭 고려 안함.
그러나 v10.1 시그널에서는 간이 ATR이 적절 (TRIX 기반이라 정밀 ATR 불필요).
**허용 범위 내.**

### [🟢 M5] backtest_v2.py:622 — 미청산 포지션 강제 청산의 수수료 반영

```python
pnl_pct = (last_close / pos.buy_price - 1) - COMMISSION * 2 - TAX
```
**정상.** 수수료+세금 차감됨.

### [🟢 M6] backtest_group_rotation.py:429 — 순환매 수수료 반영

```python
pnl_pct = (sell_price / pos.buy_price - 1) - COMMISSION * 2 - TAX
```
**정상.**

### [🟢 M7] v8_pipeline.py:358 — Zone Score 0~1 범위 보장

zone_score는 `ScoringEngine.score_all()`에서 계산.
signal_engine.py:358에서 `min(max(..., 0.0), 1.0)` 클리핑. **정상.**

---

## 4. 백테스트 엔진 검수

### [🟢 M8] Look-ahead bias 점검

| 항목 | 결과 |
|------|------|
| 매수 타이밍 | t일 시그널 → t+1 시가 매수 ✓ |
| 매도 타이밍 | 장중 high/low 체크 → 당일 반영 (현실적) ✓ |
| KOSPI 레짐 | `kospi_df.index < date` (전일 기준) ✓ |
| EWY 필터 | `get_etf_state()` pad 방식 (전일 이전) ✓ |
| Z-score | 당일 데이터로 계산 (장중 판단) ✓ |

### [🟢 M9] 중복 진입 방지

```python
if sig["ticker"] in held_tickers:
    continue
```
**정상.** v10.1 백테스트와 순환매 백테스트 모두 보유 종목 진입 차단.

### [🟢 M10] 포지션 사이징 상한

- v10.1: `MAX_POSITIONS = 5`, `MAX_DAILY_ENTRY = 2` ✓
- 순환매: `MAX_POSITIONS = 3`, `MAX_PER_GROUP = 2` ✓
- `available_slots = max_slots - len(positions)` → 초과 불가 ✓

### [🟢 M11] MDD 계산

```python
eq_arr = np.array(equities)
peak = np.maximum.accumulate(eq_arr)
dd_pct = (eq_arr - peak) / peak * 100
mdd = np.min(dd_pct)
```
**정상.** 누적 최고점 대비 하락률 방식.

---

## 5. 출력 결과 검증

### [🟢 M12] HTML 보고서 — v9 감지 로직

```python
is_v9 = candidates and "v9_rank_score" in candidates[0]
```
v9 키가 없으면 기존 v8 HTML 사용. **정상.**

### [🟢 M13] 블라인드 테스트 z-score ↔ 백테스트 일치 확인

blind_test_daily.py의 `scan_rotation()`과 backtest_group_rotation.py의
`calc_group_z_scores()`를 비교:
- 동일 공식: `z_20 = (rel_ret_20 - mean_20) / std_20`
- 동일 std 보호: `max(std, 0.01)`
- 동일 진입 조건: z_20 < -0.8, rel_ret_20 < -3%, 반전 확인, MA60 위

**일치 확인.** 라이브 스캔 결과와 백테스트 판단이 동일.

---

## 요약

| 심각도 | 건수 | 항목 |
|--------|------|------|
| 🔴 Critical | 3 | C0 (zone_score>1.0 ✅수정), C1 (반매도 PnL), C2 (반매도 이중계산) |
| 🟡 Warning | 7 | W1~W7 |
| 🟢 Minor | 13 | M1~M13 |

### Critical 평가
- **C0: zone_score 클램핑 누락 → ✅ 즉시 수정 완료** (`min(..., 1.0)` 추가)
- **C1, C2 모두 D모드(반매도 익절) 전용.** C_new 모드에서는 반매도 없으므로 영향 없음.
- 현재 운용 모드는 **C_new** (KOSPI 레짐 캡) → **C1/C2 영향 없음**.
- D모드를 사용할 경우에만 수정 필요.

### 이전 검수 대비 변경
- v8.6 C1 (pnl_pct 수수료): ✅ 수정 완료 확인
- v8.6 GPT/OpenAI 제거: ✅ 확인
- 신규 파일 (blind_test_daily.py, combine_strategies.py, backtest_group_rotation.py):
  **신규 검수 완료. Critical 이슈 없음.**

### 결론
**C0 수정 완료. 현재 운용 코드(C_new + 순환매 D모드)에 잔여 Critical 없음.**
D모드 반매도 로직 개선은 향후 과제로 남김.
T2 파라미터(W7)는 게이트 변경 작업 시 함께 검토 예정.
